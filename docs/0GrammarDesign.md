##  PL/0扩展输入文法

```
        /*Lexer*/
<字符串> ::= <字符>{<字符>}
<字符> ::= <加减运算符> | <乘除运算符> | <字母> | <数字>
<字母> ::= a|b|...X|Y|Z
<整数> ::= [+ | -]<无符号整数>
<无符号整数> ::= <非零数字>{<数字>} | 0
<数字> ::= <非零数字> | 0
<非零数字> :: = 1|2|...|9
<加减运算符> ::= + | -
<乘除运算符> ::= * | /
<关系运算符> ::= > | >= | < | <= | == | !=



        /*Parser*/
<程序> ::= [<常量声明>][<变量声明>][<函数定义>]<主函数>

<常量声明> ::= const<常量定义>;{<常量定义>;}
<常量定义> ::= int<标识符>=<整数>{, <标识符>=<整数>} | char<标识符>=<字符>{, <标识符>=<字符>}
<变量声明> ::= <变量定义>;{变量定义;}
<变量定义> ::= int(<标识符> | <标识符>'['<无符号整数>']'){, (<标识符> | <标识符>'['<无符号整数>']')}
| char(<标识符> | <标识符>'['<无符号整数>'>'){, (<标识符> | <标识符>'['<无符号整数>']')}
<标识符> ::= <字母>{<字母> | <数字>}
<类型说明符> ::= int | char 
<函数定义> ::= {<有返回值函数定义> | <无返回值函数定义>}
<有返回值函数定义> ::= <声明头部>'('<参数表>')''{'<复合语句>'}'
<无返回值函数定义> ::= void<标识符>'('<参数表>')''{'<复合语句>'}'
<声明头部> ::= int<标识符> | char <标识符>
<参数表> ::= <参数>{, <参数>} | <空>
<参数> ::= <类型标识符><标识符>

<主函数> ::= int main'('')''{'<复合语句>'}'
<复合语句> ::= [<常量说明>][<变量说明>]{<语句>}
<语句> ::= <条件语句> | <循环语句> | <有返回值函数调用语句>; | <无返回值函数调用语句>; | <赋值语句>; | <读语句>; | <写语句>; | <空>; | <返回语句>;
<条件语句> ::= if'('<条件>')'<复合语句>
<条件> ::= <表达式><关系运算符><表达式> | <表达式>
<循环语句> ::= while'('<条件>')'<复合语句>
<赋值语句> ::= <标识符>=<表达式> | <标识符>'['<表达式>']'=<表达式>
<有返回值函数调用语句> ::= <标识符>'('<值参数表>')'
<无返回值函数调用语句> ::= <标识符>'('<值参数表>')'
<读语句> ::= scanf'('<标识符>{, <标识符>}')'
<写语句> ::= printf'('<字符串>')' | printf '('<表达式>')'
<返回语句> ::= return['('<表达式>')']

<值参数表> ::= <表达式>{, <表达式>} | <空>
<表达式> ::= [+ | -]<项>{<加减运算符><项>} 
<项> ::= <因子>{<乘除运算符><因子>}
<因子> ::= <标识符>['('<值参数表>')'] | <标识符> '['<表达式>']' | <整数> | <字符> | '('<表达式>')'
```
##### 文法现限制细则

* 文法字符表: {字母，数字，+ - \* \/}的克林闭包  
* 数据类型: 32位有符号整数   数组元素下标为无符号整数>0  
* 内置类型: int char int[], char[]
* 函数需要有参数名，参数类型支持混合声明  <错误样例>: int func(int [], char, ) {}
* 语句: if-else(要求格式), while, =, func, 
* 补待充: 丰富数据类型， for, switch
* 变量声明时均不可直接赋值，全局变量由系统初始化为0，局部变量由赋值语句完成  <错误样例>: int a = 9;
